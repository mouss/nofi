'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Module = require('module');
var path = require('path');
var Utils = require('./index');
var Renderer = require('../renderer');
var Models = require('../models');

var Options = function Options(optsObj) {
    _classCallCheck(this, Options);

    this.vueFileRegex = /([\w/.\-_\d]*\.vue)/igm;
    this.requireRegex = /(require\(')([\w/.\-_\d]*\.vue)('\))/igm;
    this.appendPaths = optsObj.appendPaths || [];
    this.prependPaths = optsObj.prependPaths || [];
    this.rootPath = optsObj.rootPath || '';
    this.defaults = optsObj.defaults || {};
};

function getVueObject(componentPath, rootPath, vueComponentFileMatch) {
    var GlobalOptions = new Models.Defaults({
        rootPath: rootPath,
        component: componentPath
    });
    return new Promise(function (resolve, reject) {
        Utils.setupComponent(componentPath, GlobalOptions).then(function (component) {
            var rendered = Renderer.renderHtmlUtil(component);
            if (!rendered) {
                reject(new Error('Renderer Error'));
            } else {
                resolve({
                    rendered: rendered,
                    match: vueComponentFileMatch
                });
            }
        }).catch(function (error) {
            reject(error);
        });
    });
}

function replaceRelativePaths(code, rootPath) {
    var parentMatches = code.match(/(require\('\.\.\/)/gm);
    var currentMatches = code.match(/(require\('\.\/)/gm);
    if (parentMatches) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = parentMatches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _match = _step.value;

                code = code.replace(_match, 'require(\'' + rootPath + '/../');
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    if (currentMatches) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = currentMatches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _match2 = _step2.value;

                code = code.replace(_match2, 'require(\'' + rootPath + '/./');
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }
    }

    return code;
}

function requireFromString(code) {
    var filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var optsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    return new Promise(function (resolve, reject) {
        var options = new Options(optsObj);

        if (typeof code !== 'string') {
            throw new Error('code must be a string, not ' + (typeof code === 'undefined' ? 'undefined' : _typeof(code)));
        }
        code = replaceRelativePaths(code, options.rootPath);
        var paths = Module._nodeModulePaths(path.dirname(filename));
        var m = new Module(filename, options.rootPath);
        m.filename = filename;
        m.paths = [].concat(options.prependPaths).concat(paths).concat(options.appendPaths);
        try {
            m._compile(code, filename);
            resolve(m.exports.default);
        } catch (error) {
            //Check if the error is because the file isn't javascript
            if (error.message.includes('Unexpected token')) {
                //find matches for the require paths
                var vueComponentFileMatches = code.match(options.requireRegex);
                if (vueComponentFileMatches && vueComponentFileMatches.length > 0) {
                    //iterate through the matches
                    for (var index = 0; index < vueComponentFileMatches.length; index++) {
                        var vueComponentFileMatch = vueComponentFileMatches[index];
                        //get the file out of the require string
                        //this is because its easier to do string replace later
                        var vueComponentFile = vueComponentFileMatch.match(options.vueFileRegex);
                        if (vueComponentFile && vueComponentFile.length > 0) {
                            getVueObject(vueComponentFile[0], options.rootPath, vueComponentFileMatch).then(function (renderedItem) {
                                var rawString = renderedItem.rendered.scriptStringRaw;
                                code = code.replace(renderedItem.match, rawString);
                                //check if its the last element and then render
                                var last_element = code.match(options.requireRegex);
                                if (last_element === undefined || last_element === null) {
                                    m._compile(code, filename);
                                    resolve(m.exports.default);
                                }
                            }).catch(function (error) {
                                reject(error);
                            });
                        }
                    }
                } else {
                    reject(new Error('Couldnt require component from string: ' + error));
                }
            } else {
                reject(new Error('Couldnt require from string: ' + error));
            }
        }
    });
}

module.exports = requireFromString;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9yZXF1aXJlLmpzIl0sIm5hbWVzIjpbIk1vZHVsZSIsInJlcXVpcmUiLCJwYXRoIiwiVXRpbHMiLCJSZW5kZXJlciIsIk1vZGVscyIsIk9wdGlvbnMiLCJvcHRzT2JqIiwidnVlRmlsZVJlZ2V4IiwicmVxdWlyZVJlZ2V4IiwiYXBwZW5kUGF0aHMiLCJwcmVwZW5kUGF0aHMiLCJyb290UGF0aCIsImRlZmF1bHRzIiwiZ2V0VnVlT2JqZWN0IiwiY29tcG9uZW50UGF0aCIsInZ1ZUNvbXBvbmVudEZpbGVNYXRjaCIsIkdsb2JhbE9wdGlvbnMiLCJEZWZhdWx0cyIsImNvbXBvbmVudCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic2V0dXBDb21wb25lbnQiLCJ0aGVuIiwicmVuZGVyZWQiLCJyZW5kZXJIdG1sVXRpbCIsIkVycm9yIiwibWF0Y2giLCJjYXRjaCIsImVycm9yIiwicmVwbGFjZVJlbGF0aXZlUGF0aHMiLCJjb2RlIiwicGFyZW50TWF0Y2hlcyIsImN1cnJlbnRNYXRjaGVzIiwicmVwbGFjZSIsInJlcXVpcmVGcm9tU3RyaW5nIiwiZmlsZW5hbWUiLCJvcHRpb25zIiwicGF0aHMiLCJfbm9kZU1vZHVsZVBhdGhzIiwiZGlybmFtZSIsIm0iLCJjb25jYXQiLCJfY29tcGlsZSIsImV4cG9ydHMiLCJkZWZhdWx0IiwibWVzc2FnZSIsImluY2x1ZGVzIiwidnVlQ29tcG9uZW50RmlsZU1hdGNoZXMiLCJsZW5ndGgiLCJpbmRleCIsInZ1ZUNvbXBvbmVudEZpbGUiLCJyYXdTdHJpbmciLCJyZW5kZXJlZEl0ZW0iLCJzY3JpcHRTdHJpbmdSYXciLCJsYXN0X2VsZW1lbnQiLCJ1bmRlZmluZWQiLCJtb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLElBQU1BLFNBQVNDLFFBQVEsUUFBUixDQUFmO0FBQ0EsSUFBTUMsT0FBT0QsUUFBUSxNQUFSLENBQWI7QUFDQSxJQUFNRSxRQUFRRixRQUFRLFNBQVIsQ0FBZDtB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QW9CQSxpQkFBaUJGLE1BQWpCLEdBQTBCLENBQWxELEVBQXFEO0FBQ2pEcEMseUNBQWFzQyxpQkFBaUIsQ0FBakIsQ0FBYixFQUFrQ2QsUUFBUTFCLFFBQTFDLEVBQW9ESSxxQkFBcEQsRUFDS1EsSUFETCxDQUNVLHdCQUFnQjtBQUNsQixvQ0FBTTZCLFlBQVlDLGFBQWE3QixRQUFiLENBQXNCOEIsZUFBeEM7QUFDQXZCLHVDQUFPQSxLQUFLRyxPQUFMLENBQWFtQixhQUFhMUIsS0FBMUIsRUFBaUN5QixTQUFqQyxDQUFQO0FBQ0E7QUFDQSxvQ0FBTUcsZUFBZXhCLEtBQUtKLEtBQUwsQ0FBV1UsUUFBUTdCLFlBQW5CLENBQXJCO0FBQ0Esb0NBQUkrQyxpQkFBaUJDLFNBQWpCLElBQThCRCxpQkFBaUIsSUFBbkQsRUFBeUQ7QUFDckRkLHNDQUFFRSxRQUFGLENBQVdaLElBQVgsRUFBaUJLLFFBQWpCO0FBQ0FoQiw0Q0FBUXFCLEVBQUVHLE9BQUYsQ0FBVUMsT0FBbEI7QUFDSDtBQUNKLDZCQVZMLEVBV0tqQixLQVhMLENBV1csaUJBQVM7QUFDWlAsdUNBQU9RLEtBQVA7QUFDSCw2QkFiTDtBQWNIO0FBQ0o7QUFDSixpQkF4QkQsTUF3Qk87QUFDSFIsMkJBQU8sSUFBSUssS0FBSixDQUFVLDRDQUE0Q0csS0FBdEQsQ0FBUDtBQUNIO0FBQ0osYUE5QkQsTUE4Qk87QUFDSFIsdUJBQU8sSUFBSUssS0FBSixDQUFVLGtDQUFrQ0csS0FBNUMsQ0FBUDtBQUNIO0FBQ0o7QUFDSixLQWxETSxDQUFQO0FBbURIOztBQUVENEIsT0FBT2IsT0FBUCxHQUFpQlQsaUJBQWpCIiwiZmlsZSI6InJlcXVpcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuY29uc3QgTW9kdWxlID0gcmVxdWlyZSgnbW9kdWxlJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5jb25zdCBSZW5kZXJlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVyJyk7XG5jb25zdCBNb2RlbHMgPSByZXF1aXJlKCcuLi9tb2RlbHMnKTtcblxuY2xhc3MgT3B0aW9ucyB7XG4gICAgdnVlRmlsZVJlZ2V4OiBSZWdFeHA7XG4gICAgcmVxdWlyZVJlZ2V4OiBSZWdFeHA7XG4gICAgYXBwZW5kUGF0aHM6IHN0cmluZ1tdO1xuICAgIHByZXBlbmRQYXRoczogc3RyaW5nW107XG4gICAgcm9vdFBhdGg6IHN0cmluZztcbiAgICBkZWZhdWx0czogTW9kZWxzLkRlZmF1bHRzO1xuICAgIGNvbnN0cnVjdG9yKG9wdHNPYmo6IE9iamVjdCkge1xuICAgICAgICB0aGlzLnZ1ZUZpbGVSZWdleCA9IC8oW1xcdy8uXFwtX1xcZF0qXFwudnVlKS9pZ207XG4gICAgICAgIHRoaXMucmVxdWlyZVJlZ2V4ID0gLyhyZXF1aXJlXFwoJykoW1xcdy8uXFwtX1xcZF0qXFwudnVlKSgnXFwpKS9pZ207XG4gICAgICAgIHRoaXMuYXBwZW5kUGF0aHMgPSBvcHRzT2JqLmFwcGVuZFBhdGhzIHx8IFtdO1xuICAgICAgICB0aGlzLnByZXBlbmRQYXRocyA9IG9wdHNPYmoucHJlcGVuZFBhdGhzIHx8IFtdO1xuICAgICAgICB0aGlzLnJvb3RQYXRoID0gb3B0c09iai5yb290UGF0aCB8fCAnJztcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IG9wdHNPYmouZGVmYXVsdHMgfHwge307XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRWdWVPYmplY3QoY29tcG9uZW50UGF0aDogc3RyaW5nLCByb290UGF0aDogc3RyaW5nLCB2dWVDb21wb25lbnRGaWxlTWF0Y2g6IHN0cmluZyk6IFByb21pc2UgPCB7cmVuZGVyZWQ6T2JqZWN0LCBtYXRjaDogc3RyaW5nfSA+IHtcbiAgICBjb25zdCBHbG9iYWxPcHRpb25zID0gbmV3IE1vZGVscy5EZWZhdWx0cyh7XG4gICAgICAgIHJvb3RQYXRoOiByb290UGF0aCxcbiAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnRQYXRoXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgVXRpbHMuc2V0dXBDb21wb25lbnQoY29tcG9uZW50UGF0aCwgR2xvYmFsT3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZWQgPSBSZW5kZXJlci5yZW5kZXJIdG1sVXRpbChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignUmVuZGVyZXIgRXJyb3InKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZDogcmVuZGVyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaDogdnVlQ29tcG9uZW50RmlsZU1hdGNoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVJlbGF0aXZlUGF0aHMoY29kZTogc3RyaW5nLCByb290UGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBwYXJlbnRNYXRjaGVzID0gY29kZS5tYXRjaCgvKHJlcXVpcmVcXCgnXFwuXFwuXFwvKS9nbSk7XG4gICAgY29uc3QgY3VycmVudE1hdGNoZXMgPSBjb2RlLm1hdGNoKC8ocmVxdWlyZVxcKCdcXC5cXC8pL2dtKTtcbiAgICBpZiAocGFyZW50TWF0Y2hlcykge1xuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHBhcmVudE1hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UobWF0Y2gsIGByZXF1aXJlKCcke3Jvb3RQYXRofS8uLi9gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudE1hdGNoZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBjdXJyZW50TWF0Y2hlcykge1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShtYXRjaCwgYHJlcXVpcmUoJyR7cm9vdFBhdGh9Ly4vYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29kZTtcbn1cblxuXG5mdW5jdGlvbiByZXF1aXJlRnJvbVN0cmluZyhjb2RlOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcgPSAnJywgb3B0c09iajogT2JqZWN0ID0ge30pOiBQcm9taXNlIDwgT2JqZWN0ID4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRzT2JqKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvZGUgbXVzdCBiZSBhIHN0cmluZywgbm90ICcgKyB0eXBlb2YgY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZSA9IHJlcGxhY2VSZWxhdGl2ZVBhdGhzKGNvZGUsIG9wdGlvbnMucm9vdFBhdGgpO1xuICAgICAgICBsZXQgcGF0aHMgPSBNb2R1bGUuX25vZGVNb2R1bGVQYXRocyhwYXRoLmRpcm5hbWUoZmlsZW5hbWUpKTtcbiAgICAgICAgdmFyIG0gPSBuZXcgTW9kdWxlKGZpbGVuYW1lLCBvcHRpb25zLnJvb3RQYXRoKTtcbiAgICAgICAgbS5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICBtLnBhdGhzID0gW10uY29uY2F0KG9wdGlvbnMucHJlcGVuZFBhdGhzKS5jb25jYXQocGF0aHMpLmNvbmNhdChvcHRpb25zLmFwcGVuZFBhdGhzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG0uX2NvbXBpbGUoY29kZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmVzb2x2ZShtLmV4cG9ydHMuZGVmYXVsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvL0NoZWNrIGlmIHRoZSBlcnJvciBpcyBiZWNhdXNlIHRoZSBmaWxlIGlzbid0IGphdmFzY3JpcHRcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdVbmV4cGVjdGVkIHRva2VuJykpIHtcbiAgICAgICAgICAgICAgICAvL2ZpbmQgbWF0Y2hlcyBmb3IgdGhlIHJlcXVpcmUgcGF0aHNcbiAgICAgICAgICAgICAgICBsZXQgdnVlQ29tcG9uZW50RmlsZU1hdGNoZXMgPSBjb2RlLm1hdGNoKG9wdGlvbnMucmVxdWlyZVJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAodnVlQ29tcG9uZW50RmlsZU1hdGNoZXMgJiYgdnVlQ29tcG9uZW50RmlsZU1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvL2l0ZXJhdGUgdGhyb3VnaCB0aGUgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdnVlQ29tcG9uZW50RmlsZU1hdGNoZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdnVlQ29tcG9uZW50RmlsZU1hdGNoID0gdnVlQ29tcG9uZW50RmlsZU1hdGNoZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIGZpbGUgb3V0IG9mIHRoZSByZXF1aXJlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIGlzIGJlY2F1c2UgaXRzIGVhc2llciB0byBkbyBzdHJpbmcgcmVwbGFjZSBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdnVlQ29tcG9uZW50RmlsZSA9IHZ1ZUNvbXBvbmVudEZpbGVNYXRjaC5tYXRjaChvcHRpb25zLnZ1ZUZpbGVSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodnVlQ29tcG9uZW50RmlsZSAmJiB2dWVDb21wb25lbnRGaWxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRWdWVPYmplY3QodnVlQ29tcG9uZW50RmlsZVswXSwgb3B0aW9ucy5yb290UGF0aCwgdnVlQ29tcG9uZW50RmlsZU1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZW5kZXJlZEl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3U3RyaW5nID0gcmVuZGVyZWRJdGVtLnJlbmRlcmVkLnNjcmlwdFN0cmluZ1JhdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmVuZGVyZWRJdGVtLm1hdGNoLCByYXdTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBpdHMgdGhlIGxhc3QgZWxlbWVudCBhbmQgdGhlbiByZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RfZWxlbWVudCA9IGNvZGUubWF0Y2gob3B0aW9ucy5yZXF1aXJlUmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RfZWxlbWVudCA9PT0gdW5kZWZpbmVkIHx8IGxhc3RfZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uX2NvbXBpbGUoY29kZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobS5leHBvcnRzLmRlZmF1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDb3VsZG50IHJlcXVpcmUgY29tcG9uZW50IGZyb20gc3RyaW5nOiAnICsgZXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NvdWxkbnQgcmVxdWlyZSBmcm9tIHN0cmluZzogJyArIGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlRnJvbVN0cmluZztcbiJdfQ==